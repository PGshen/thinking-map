# AI 编程实践：从想法到产品 - 技术博客系列大纲

## 系列概述

本系列博客记录了一个真实的 AI 辅助产品开发过程，重点分享在 ThinkingMap 项目开发中遇到的实际问题、思考过程和解决方案。

**目标读者**：
- 正在使用或想要使用 AI 编程工具的开发者
- 对 AI Agent 系统开发感兴趣的工程师
- 希望了解复杂前端项目实践的开发者
- 想要学习实时通信系统设计的技术人员

**核心价值**：
- 真实的开发过程记录，包括踩坑和解决方案
- AI 编程工具的实际使用技巧和局限性
- 复杂系统架构的演进过程和决策思考
- 可直接应用的技术方案和代码实践

---
## 第零篇：缘起：为什么写这个系列，以及关于 Thinking-Map 项目的一切

### 内容大纲

**1. 系列博客开篇介绍**
- 为什么决定写这个系列博客
- 记录真实开发过程的初衷
- 希望为读者带来什么价值

**2. 博客所关联项目 thinking-map 介绍**
- 项目的核心理念：可视化并加速思考过程
- 主要功能和应用场景
- 项目的开源地址和社区

**3. 技术栈概览**
- 前端：Next.js 15、ReactFlow、Zustand
- 后端：Go、eino、Gin、GORM
- AI：Multi Agent、ReAct、上下文工程

**4. 系列文章结构导览**
- 各篇文章的核心主题和关联
- 建议的阅读顺序和重点
- 如何从项目中找到对应的代码实现

## 第一篇：从痛点到产品设计 - 想法、设计、选型的完整历程

### 内容大纲

**1. 真实的痛点发现过程**
- 使用 Claude、ChatGPT 时的实际困扰
- "黑盒"问题在日常工作中的具体表现
- 为什么现有工具无法满足复杂思考需求
- 第一次萌生"可视化思考过程"想法的契机

**2. 与 AI 的需求探索实录**
- 如何向 AI 描述一个模糊的想法
- 在对话中逐步明确需求的真实过程
- AI 提出的问题如何帮助澄清思路
- 遇到的理解偏差和纠正过程

**3. 产品概念的迭代演进**
- 从"AI 助手改进"到"思考过程可视化"的转变
- 核心功能的反复讨论和调整
- 技术可行性对产品设计的影响
- 用户体验考虑如何改变最初设想

**4. 早期原型的快速验证**
- 用简单工具验证核心假设
- 与朋友、同事讨论时的反馈
- 哪些想法被证明不可行
- 哪些意外发现改变了产品方向

**5. 技术选型的纠结与决策**
- **前端技术栈的选择历程**
  - 为什么最终选择 React 生态
  - Next.js 15 的踩坑经历
  - ReactFlow 的发现和深入使用体验
- **后端技术栈的艰难抉择**
  - Go vs Node.js 的内心斗争
  - 偶然发现 eino 框架的过程
  - 字节跳动技术栈的吸引力
- **AI 辅助技术选型的实践**
  - 在技术盲区中的 AI 求助策略
  - AI 辅助调研的具体方法
  - 验证和筛选 AI 建议的经验

**6. 文档驱动的开发准备**
- 产品需求文档的 AI 协助编写过程
- 技术架构设计的迭代完善
- API 设计和前端组件规划
- 这些文档在后续开发中的关键作用

**关键收获**：
- 从想法到可执行方案的完整思考框架
- AI 辅助产品设计和技术选型的实用方法
- 早期验证和文档准备的重要性
- 避免过度设计和技术选型陷阱的经验

---

## 第二篇：AI 编程工具的真实体验 - 从期待到现实的落差与适应

### 内容大纲

**1. 初次接触 AI 编程工具的震撼与困惑**
- **第一次使用 AI 编程工具的体验**
  - 代码自动补全带来的惊喜
  - 面对 AI 建议时的不知所措
  - 过度依赖 AI 导致的思考惰性
- **工具选择的迷茫期**
  - 不同 AI 编程工具的试用对比
  - 每个工具的意外发现和失望
  - 为什么最终选择了多工具组合

**2. AI 编程工具的利与弊：好用与不好用的地方**
- **整体利弊评估**
  - 提升开发效率与覆盖更多知识盲区
  - 可能引入理解偏差与隐性复杂度
- **好用的场景**
  - 重复性或模板化代码生成
  - 跨文件检索与重构建议
  - 类型补全与测试样例草拟
- **不好用的场景**
  - 复杂业务语义与领域规则
  - 核心架构设计与关键抽象
  - 需强一致性的安全与合规逻辑

**3. AI 编程工具使用过程中的真实问题**
- **代码质量的担忧**
  - AI 生成代码的质量参差不齐
  - 如何识别和修正 AI 的错误建议
  - 过度优化导致的代码复杂化
- **上下文理解的局限性**
  - 工具规则/配置的反复调试
  - 项目复杂度增加后的理解偏差
  - 如何通过文档改善 AI 理解

**4. AI 编程工具的意外收获与挫折**
- **语义搜索的强大与局限**
  - 找到关键代码时的兴奋
  - 搜索结果不准确时的沮丧
  - 如何优化搜索策略
- **项目级理解的价值**
  - 跨文件重构的便利性
  - 架构级建议的参考价值
  - 复杂逻辑处理的局限性

**5. 实际开发中的人机协作模式**
- **提示工程的学习曲线**
  - 从简单指令到复杂上下文的演进
  - 失败的提示案例和改进过程
  - 如何让 AI 理解你的真实意图
- **AI 编程工具的使用技巧与经验**
  - **提示词编写的实用技巧**
    - 如何描述需求让 AI 更好理解
    - 分步骤引导 AI 完成复杂任务
    - 提供足够上下文信息的方法
    - 避免模糊表达的具体策略
  - **代码生成的优化策略**
    - 先让 AI 理解整体架构再写代码
    - 如何引导 AI 遵循项目代码规范
    - 分模块生成代码的有效方法
    - 利用 AI 进行代码重构的技巧
  - **调试与修复的协作模式**
    - 如何向 AI 描述 bug 现象
    - 让 AI 分析错误日志的方法
    - 与 AI 协作定位问题根源
    - 验证 AI 修复方案的策略
- **代码审查的新挑战**
  - 如何审查 AI 生成的代码
  - 发现隐藏 bug 的经验
  - 保持代码风格一致性的困难

**6. 效率提升与新问题的平衡**
- **开发速度的显著提升**
  - 具体的时间节省数据
  - 哪些任务最适合 AI 辅助
  - 哪些工作仍需人工完成
- **新的技能要求**
  - 提示工程能力的重要性
  - 代码审查技能的升级需求
  - 架构思维的更高要求

**关键收获**：
- AI 编程工具的实用使用策略
- 提示词工程的实用技巧
- 人机协作的最佳实践模式
- 避免 AI 依赖陷阱的方法
- 提升 AI 辅助效果的具体技巧

---

## 第三篇：系统架构设计实践 - eino 框架与 Multi Agent 协作的探索之路

### 内容大纲

**1. 架构设计的初始思考**
- 从单一 AI 调用到 Multi Agent 系统的演进
- 为什么选择了 eino 框架作为核心
- 对比其他 AI 框架时的纠结和最终决策

**2. Multi Agent 系统架构设计**
- **Agent 角色设计与职责分工**
  - 问题理解 Agent：自然语言处理和意图识别
  - 拆解决策 Agent：复杂度评估和策略选择
  - 问题拆解 Agent：递归拆解和子问题生成
  - 结论生成 Agent：信息整合和推理链构建
- **基于 eino 框架的 Agent 实现**
  - eino 的 Agent、Chain、Node 概念在项目中的应用
  - 如何用 eino 构建不同职责的 Agent
  - eino 框架的 Multi Agent 协作机制

**3. ReAct 框架在 Multi Agent 中的应用**
- **ReAct（Reasoning and Acting）设计模式**
  - ReAct 框架的核心理念：推理与行动的循环
  - 如何在 ThinkingMap 中实现 ReAct 模式
  - 思考链（Chain of Thought）与行动链的结合
- **ReAct Agent 的具体实现**
  - 推理阶段：问题分析和策略制定
  - 行动阶段：具体操作和工具调用
  - 观察阶段：结果评估和下一步决策
- **多个 ReAct Agent 的协作机制**
  - Agent 间的推理结果共享
  - 行动结果的传递与验证
  - 协作推理的冲突解决策略

**4. 架构实施中的挑战与妥协**
- **第一次尝试的混乱**
  - Agent 之间的"沟通障碍"
  - 意想不到的循环依赖
  - 调试时的"黑盒"困境
- **协作机制的艰难探索**
  - 消息传递格式的反复调整
  - 使用全局状态管理数据

**5. 妥协后的实用方案**
- 哪些理想化的设计被简化
- 实际采用的协作模式
- 监控和调试的实用方法
- 什么时候单 Agent 反而更好
- 技术栈选择的经验总结

**关键收获**：
- eino 框架的实际应用经验和局限性
- Multi Agent 系统设计的复杂性陷阱
- ReAct 框架在实际项目中的实现经验
- 架构设计中理想与现实的平衡

---

## 第四篇：关键技术攻坚 - SSE、上下文工程与流式解析的实践之路

### 内容大纲

**1. SSE 实时通信：从理想到现实的距离**
- **天真设想与残酷现实**
  - “实时显示 AI 思考过程应该很简单吧？”——最初的天真想法
  - 为什么选择 SSE 而不是 WebSocket：技术选型的权衡
  - 第一版实现的“美好”设想与现实的巨大差距
- **分布式环境下的挑战**
  - 单机版本的顺利实现 vs 多实例部署的困境
  - Redis 发布订阅：从引入到调试的踩坑记录
  - 连接状态管理的复杂性与最终解决方案
- **最终的技术妥协**
  - 理想化设计的现实调整：从“完美”到“可用”
  - Redis 发布订阅的性能瓶颈 -> 优先本地分发的务实选择
  - 用户体验与技术实现的艰难平衡

**2. 上下文工程：为 AI Agent 构建“世界观”**
- **从“提示工程”到“上下文工程”的思维跃迁**
  - 提示词工程的局限性：一次性对话的优化困境
  - 上下文工程的核心：为 Agent 构建动态、结构化的“世界观”
  - 为什么仅仅优化提示词是远远不够的？
- **ThinkingMap 的三层上下文体系**
  - **第一层：思考树（Thinking Map）- 宏观任务的结构化上下文**
    - 核心职责：为 Agent 提供任务的“全景地图”
    - 上下文管理器的实现：如何自动收集上下文信息
  - **第二层：ReAct Agent - 执行循环中的“短期记忆”**
    - 核心职责：管理 Agent 的“思考-行动”迭代循环
    - `AgentState` 的作用：记录每一步交互的“工作记忆”
    - ReAct 循环中的上下文流转机制
  - **第三层：多智能体系统（Multi-Agent）- 复杂任务的“元认知”与编排**
    - 核心职责：对复杂任务进行规划、协作、反思和调整
    - `EnhancedState` 的设计：跟踪全局规划与执行状态
    - 元认知工作流：从“创建规划”到“反馈处理”的闭环

**3. 实时流式 JSON 解析：确保 AI 结构化输出的“最后一公里”**
- **为什么需要流式解析？**
  - 业务需求：LLM 返回结构化数据，保证前端交互的稳定性
  - 技术挑战：传统 JSON 解析无法满足实时交互的需求
- **手写一个有限状态机（FSM）解析器**
  - 设计目标：轻量、高效、低延迟，支持增量解析与路径回调
  - 核心组件：`StreamingJsonParser` 与 `SimplePathMatcher`
  - 状态机实现：逐字符解析 JSON 的状态转移过程
- **关键特性与实践**
  - `SimplePathMatcher`：通过 `$.a.b[*]` 语法精确订阅数据
  - `realtime` 与 `incremental` 模式的妙用
  - 在 ThinkingMap 中的实践：Go 后端与前端的集成

**关键收获**：
- SSE 实时通信在分布式环境下的实践经验与教训
- 上下文工程从理论到实践的落地方法
- 手写流式 JSON 解析器的设计与实现技巧
- 在复杂技术问题中，从“理想”到“现实”的妥协与智慧

---



## 第五篇：项目复盘与未来展望：收获、遗憾与展望

- [项目复盘：收获、遗憾与未来展望](./05-retrospective-and-future.md)

### 内容大纲

**1. 整个项目的真实感受**
- 从兴奋到焦虑再到接受的心路历程
- 哪些地方超出了预期
- 哪些地方让人失望

**2. 最大的收获和遗憾**
- 意想不到的技能提升
- AI 编程带来的思维转变
- 如果重新开始会避免的坑
- 当初应该更重视的地方

**3. 对 AI 编程工具的重新认识**
- 从神化到理性的过程
- 什么时候 AI 真的有用
- 什么时候还是要靠自己
- 人机协作的最佳节奏

**4. 技术选择的反思**
- 哪些技术选择是对的
- 哪些选择现在看来有问题
- 如果重新选择会怎样
- 给类似项目的建议

**5. 写给未来的自己**
- 这个项目教会了我什么
- 对 AI 时代开发的新理解
- 下一个项目想要尝试的方向
- 给其他开发者的真心话

**关键收获**：
- 诚实的项目反思
- 实用的经验教训
- 对 AI 编程的理性认知
- 给后来者的参考

---

## 系列特色与价值

### 1. 真实经历分享
- 记录实际开发过程中的困惑和突破
- 分享踩坑经验和解决方案
- 展示思考过程的演进轨迹

### 2. 问题导向
- 聚焦开发过程中遇到的实际问题
- 分析问题产生的根本原因
- 提供可操作的解决思路

### 3. AI 协作实录
- 真实的 AI 工具使用体验
- 人机协作中的挫折与收获
- 提示工程的实际应用技巧

### 4. 技术选择的思考过程
- 决策背后的真实考量
- 技术方案的权衡与妥协
- 从错误中学到的经验教训

### 5. 持续反思与改进
- 开发过程中的认知升级
- 方法论的迭代优化
- 对技术趋势的个人思考

---

## 目标读者收益

**初级开发者**：
- 学习现代全栈开发技术栈
- 了解 AI 编程工具的使用方法
- 掌握产品开发的完整流程

**中级开发者**：
- 深入理解复杂系统的架构设计
- 学习性能优化的实践方法
- 提升技术选型的决策能力

**高级开发者**：
- 探索 AI 技术在工程实践中的应用
- 学习大型项目的架构演进经验
- 获得技术管理的实践参考

**技术管理者**：
- 了解现代技术栈的发展趋势
- 学习技术团队的协作方法
- 获得产品技术规划的参考

---

## 写作计划

**发布频率**：每周 1 篇，预计 2 个月完成整个系列

**内容风格**：每篇 3000-5000 字，重点分享实际经验和思考过程

**配套资源**：
- 项目源码的关键部分
- 实际遇到问题的代码示例
- 决策过程的思维导图
- 踩坑经验的总结清单

**持续互动**：
- 收集读者的类似经历和不同观点
- 根据反馈补充遗漏的重要细节
- 更新技术发展带来的新思考

这个系列希望成为 AI 编程实践者的经验分享，帮助其他开发者少走弯路，更好地利用 AI 工具提升开发效率。