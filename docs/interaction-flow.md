# ThinkingMap 交互流程设计

## 1. 整体流程概述

ThinkingMap的交互流程分为两个主要阶段：
1. **问题理解阶段**：用户输入问题，系统理解并确认问题细节
2. **问题解答阶段**：基于理解的问题进行结构化分析和解答

### 1.1 角色定义
- **用户**：问题提出者和决策者
- **前端**：React + TypeScript 客户端应用
- **后端**：Golang + gin 服务端应用
- **Agent服务**：基于 cloudwego/eino 的AI智能体服务

### 1.2 核心交互原则
- 用户始终拥有控制权，可以在任何阶段干预和调整
- 系统提供透明的思考过程可视化
- 支持多轮对话和迭代优化
- 实时反馈和状态同步

## 2. 问题理解阶段

### 2.1 问题输入与初步分析

#### 2.1.1 用户输入问题
```
用户操作：
1. 在问题输入界面输入问题文本（50-200字推荐）
2. 选择问题类型（研究型、创意型、分析型、规划型）
3. 点击"开始分析"按钮

前端处理：
1. 验证问题长度和格式
2. 收集问题类型信息
3. 发送问题到后端进行初步分析
```

#### 2.1.2 后端问题理解
```
后端处理：
1. 接收问题输入请求
2. 调用 Intent Agent 进行用户意图识别
3. 调用 Analysis Agent 进行问题初步分析
4. 返回问题理解结果

API接口：
POST /api/v1/thinking/analyze
{
  "question": "用户输入的问题",
  "question_type": "research|creative|analysis|planning",
  "user_id": "用户ID"
}

返回结果：
{
  "code": 200,
  "data": {
    "understanding": {
      "core_question": "核心问题",
      "target": "目标描述",
      "key_points": ["关键点1", "关键点2"],
      "constraints": ["约束条件1", "约束条件2"],
      "context": "上下文背景",
      "complexity": "high|medium|low"
    },
    "suggestions": ["建议1", "建议2"],
    "clarification_questions": ["澄清问题1", "澄清问题2"]
  }
}
```

### 2.2 问题澄清与确认

#### 2.2.1 问题理解展示
```
前端展示：
1. 显示系统理解的核心问题
2. 展示目标描述和关键点
3. 列出约束条件和上下文
4. 提供澄清问题列表
5. 允许用户编辑和补充信息

界面组件：
- 问题理解确认面板
- 可编辑的文本区域
- 澄清问题回答区域
- 确认/修改按钮
```

#### 2.2.2 多轮澄清对话
```
交互流程：
1. 用户查看系统理解结果
2. 用户回答澄清问题或提供补充信息
3. 前端发送澄清信息到后端
4. 后端调用 Agent 服务更新理解
5. 返回更新后的理解结果
6. 重复直到用户确认

API接口：
POST /api/v1/thinking/clarify
{
  "session_id": "会话ID",
  "clarifications": {
    "answers": ["回答1", "回答2"],
    "additional_info": "补充信息",
    "modifications": {
      "target": "修改后的目标",
      "constraints": ["修改后的约束"]
    }
  }
}
```

#### 2.2.3 问题确认
```
用户确认：
1. 用户检查最终的问题理解
2. 确认目标、关键点、约束条件
3. 点击"确认并开始解答"按钮

后端处理：
1. 创建 thinking_map 记录
2. 创建根 thinking_node
3. 初始化工作区状态
4. 返回 map_id 和根节点信息

API接口：
POST /api/v1/thinking/confirm
{
  "session_id": "会话ID",
  "final_understanding": {
    "problem": "最终问题描述",
    "target": "最终目标",
    "key_points": ["关键点"],
    "constraints": ["约束条件"]
  }
}

返回结果：
{
  "code": 200,
  "data": {
    "map_id": "思维导图ID",
    "root_node": {
      "node_id": "根节点ID",
      "question": "问题",
      "target": "目标",
      "status": "pending"
    }
  }
}
```

## 3. 问题解答阶段

### 3.1 工作区初始化

#### 3.1.1 前端进入工作区
```
前端处理：
1. 接收 map_id 和根节点信息
2. 初始化可视化工作区
3. 显示根节点
4. 建立 SSE 连接
5. 加载当前执行状态

SSE连接：
GET /api/v1/sse/connect?map_id={map_id}&user_id={user_id}
```

#### 3.1.2 SSE 连接建立
```
后端处理：
1. 验证用户权限和 map_id 有效性
2. 建立 SSE 连接
3. 发送当前状态事件
4. 监听节点变更事件

SSE事件格式：
event: connection_established
data: {
  "map_id": "思维导图ID",
  "current_status": "ready",
  "active_nodes": ["节点ID列表"]
}
```

### 3.2 节点执行流程

#### 3.2.1 节点信息展示
```
前端处理：
1. 获取当前执行中的节点
2. 展开右侧操作面板
3. 切换到"节点信息"Tab
4. 显示节点详细信息

节点信息内容：
- 当前问题描述
- 目标描述
- 上下文背景（父节点信息）
- 依赖关系状态
- 执行控制按钮

API接口：
GET /api/v1/nodes/{node_id}
```

#### 3.2.2 依赖检查与执行控制
```
依赖检查：
1. 前端检查节点依赖关系
2. 显示依赖状态列表
3. 未满足依赖时禁用执行按钮
4. 满足依赖时显示"开始执行"按钮

依赖状态显示：
- 父节点完成状态
- 子节点依赖关系
- 阻塞原因说明
```

#### 3.2.3 执行决策
```
用户操作：
1. 确认节点信息无误
2. 点击"开始执行"按钮

后端处理：
1. 接收执行请求
2. 调用 Agent 服务判断执行动作
3. 返回执行决策结果

API接口：
POST /api/v1/thinking/execute
{
  "node_id": "节点ID",
  "action": "start"
}

返回结果：
{
  "code": 200,
  "data": {
    "action": "decompose|conclude",
    "reason": "执行原因",
    "next_tab": "decompose|conclusion"
  }
}
```

### 3.3 问题拆解流程

#### 3.3.1 拆解确认
```
前端处理：
1. 接收拆解决策
2. 弹出拆解确认对话框
3. 询问用户是否进行拆解
4. 用户选择"拆解"或"直接解答"

用户选择：
- 选择"拆解"：进入拆解Tab
- 选择"直接解答"：进入结论Tab
```

#### 3.3.2 问题拆解执行
```
后端处理：
1. 调用 Decompose Agent 进行问题拆解
2. 分析问题复杂度
3. 生成子问题列表
4. 确定子问题依赖关系
5. 创建子节点

Agent服务调用：
POST /api/v1/thinking/decompose
{
  "node_id": "节点ID",
  "question": "问题描述",
  "context": "上下文信息"
}

拆解结果：
{
  "sub_problems": [
    {
      "question": "子问题1",
      "target": "子目标1",
      "priority": 1,
      "dependencies": []
    },
    {
      "question": "子问题2", 
      "target": "子目标2",
      "priority": 2,
      "dependencies": ["子问题1"]
    }
  ],
  "strategy": "拆解策略说明"
}
```

#### 3.3.3 子节点创建与同步
```
后端处理：
1. 为每个子问题创建 thinking_node
2. 设置节点依赖关系
3. 通过 SSE 发送节点创建事件
4. 更新父节点状态

SSE事件：
event: node_created
data: {
  "node_id": "新节点ID",
  "parent_id": "父节点ID",
  "node_type": "analysis",
  "question": "子问题",
  "target": "子目标",
  "position": {"x": 100, "y": 200},
  "dependencies": ["依赖节点ID"]
}
```

#### 3.3.4 拆解过程交互
```
前端处理：
1. 接收 SSE 节点创建事件
2. 实时更新可视化工作区
3. 在拆解Tab显示拆解进度
4. 允许用户调整拆解结果
5. 提供拆解反馈和重新生成功能

用户交互：
- 查看拆解进度
- 调整子问题描述
- 修改依赖关系
- 添加新的子问题
- 确认拆解结果
- 提供拆解反馈
- 重新生成拆解结果

拆解进度展示：
1. 显示当前拆解阶段（分析问题 → 生成子问题 → 确定依赖关系 → 创建节点）
2. 实时进度条显示拆解完成度
3. 显示已生成的子问题数量
4. 展示拆解策略和思路

子问题调整功能：
1. 双击子问题可编辑描述
2. 拖拽调整子问题顺序
3. 右键菜单提供删除、复制、移动选项
4. 支持批量选择和操作

依赖关系管理：
1. 可视化显示依赖关系图
2. 拖拽连线调整依赖关系
3. 显示依赖冲突和循环依赖警告
4. 提供依赖关系验证功能

拆解反馈机制：
1. 用户可对整体拆解结果进行评分（1-5星）
2. 提供反馈输入框，描述不满意的地方
3. 支持标记特定子问题为"需要调整"
4. 可选择重新生成整个拆解或部分调整

重新生成拆解：
1. 用户点击"重新生成"按钮
2. 前端发送重新生成请求到后端
3. 后端调用 Agent 服务重新进行拆解
4. 可选择保留部分已确认的子问题
5. 支持指定新的拆解策略或方向

API接口：
POST /api/v1/thinking/decompose/feedback
{
  "node_id": "节点ID",
  "feedback": {
    "rating": 3,
    "comments": "拆解不够细致，缺少技术实现层面",
    "issues": [
      {
        "sub_problem_id": "子问题ID",
        "issue": "问题描述过于宽泛"
      }
    ],
    "suggestions": "希望增加技术选型相关的子问题"
  },
  "action": "regenerate|adjust"
}

POST /api/v1/thinking/decompose/regenerate
{
  "node_id": "节点ID",
  "strategy": "technical_focus|business_focus|comprehensive",
  "preserve_nodes": ["保留的节点ID"],
  "new_direction": "新的拆解方向描述"
}

拆解结果确认：
1. 用户检查所有子问题描述
2. 确认依赖关系正确性
3. 验证拆解策略合理性
4. 点击"确认拆解结果"进入下一阶段

确认后处理：
1. 锁定拆解结果，防止意外修改
2. 更新父节点状态为"已拆解"
3. 初始化所有子节点为"待执行"状态
4. 通知工作区切换到下一个执行节点
```

### 3.4 问题解答流程

#### 3.4.1 结论生成准备
```
前端处理：
1. 切换到"结论生成"Tab
2. 显示当前节点相关信息
3. 展示信息汇总
4. 准备开始结论生成

信息汇总：
- 当前问题描述
- 相关上下文信息
- 子节点结论（如果有）
- 外部知识检索结果
```

#### 3.4.2 AI 解答服务
```
后端处理：
1. 调用 Analysis Agent 进行信息检索
2. 调用 Reasoning Agent 进行逻辑推理
3. 调用 Synthesis Agent 生成结论
4. 实时推送思考进度

Agent服务调用：
POST /api/v1/thinking/conclude
{
  "node_id": "节点ID",
  "question": "问题描述",
  "context": "上下文信息",
  "sub_conclusions": ["子节点结论"]
}

SSE进度事件：
event: thinking_progress
data: {
  "node_id": "节点ID",
  "stage": "analyzing|reasoning|synthesizing",
  "progress": 50,
  "message": "正在分析问题..."
}
```

#### 3.4.3 结论生成与确认
```
后端处理：
1. 生成初步结论
2. 发送结论到前端
3. 等待用户确认或调整

结论格式：
{
  "conclusion": "生成的结论",
  "confidence": 0.85,
  "evidence": ["证据1", "证据2"],
  "limitations": ["局限性1", "局限性2"],
  "recommendations": ["建议1", "建议2"]
}
```

#### 3.4.4 用户反馈与迭代
```
用户交互：
1. 查看生成的结论
2. 提出疑问或要求调整
3. 提供补充信息
4. 确认最终结论

前端处理：
1. 显示结论内容
2. 提供反馈输入框
3. 发送用户反馈到后端
4. 接收调整后的结论

API接口：
POST /api/v1/thinking/feedback
{
  "node_id": "节点ID",
  "feedback": "用户反馈",
  "action": "adjust|confirm"
}
```

### 3.5 节点完成与流程控制

#### 3.5.1 节点完成处理
```
后端处理：
1. 用户确认结论后标记节点为完成
2. 更新节点状态和结论
3. 检查依赖关系
4. 通知相关节点依赖状态变化

SSE事件：
event: node_updated
data: {
  "node_id": "节点ID",
  "updates": {
    "status": "completed",
    "conclusion": "最终结论"
  }
}
```

#### 3.5.2 下一个节点选择
```
后端处理：
1. 扫描所有待执行节点
2. 检查节点依赖关系
3. 选择满足依赖条件的节点
4. 通知前端切换到新节点

节点选择逻辑：
- 优先选择依赖已完成的节点
- 按优先级排序
- 考虑用户偏好设置
```

#### 3.5.3 工作区状态更新
```
前端处理：
1. 接收节点完成事件
2. 更新节点状态显示
3. 高亮下一个执行节点
4. 自动展开新节点信息面板

状态同步：
- 节点状态：pending → executing → completed
- 工作区状态：ready → processing → completed
- 进度指示器更新
```

## 4. 异常处理与错误恢复

### 4.1 网络异常处理
```
SSE连接断开：
1. 前端检测连接状态
2. 自动重连机制
3. 重连成功后同步状态
4. 显示连接状态指示

API请求失败：
1. 显示错误提示
2. 提供重试选项
3. 保存本地状态
4. 网络恢复后同步
```

### 4.2 Agent服务异常
```
服务不可用：
1. 显示服务状态提示
2. 提供手动重试选项
3. 保存当前进度
4. 服务恢复后继续执行

执行超时：
1. 显示超时提示
2. 提供继续等待或取消选项
3. 记录超时日志
4. 支持断点续传
```

### 4.3 数据一致性保证
```
状态同步：
1. 定期同步节点状态
2. 冲突检测和解决
3. 版本控制机制
4. 回滚支持

数据恢复：
1. 本地缓存机制
2. 服务端状态备份
3. 增量同步策略
4. 完整性校验
```

## 5. 性能优化策略

### 5.1 前端优化
```
渲染优化：
- 虚拟滚动处理大量节点
- 懒加载节点详情
- 防抖处理用户输入
- 缓存常用数据

状态管理：
- 本地状态缓存
- 增量更新策略
- 批量操作支持
- 内存使用优化
```

### 5.2 后端优化
```
并发处理：
- 异步任务队列
- 连接池管理
- 负载均衡
- 缓存策略

数据库优化：
- 索引优化
- 查询优化
- 读写分离
- 分页处理
```

### 5.3 Agent服务优化
```
调用优化：
- 批量处理请求
- 结果缓存
- 超时控制
- 降级策略

资源管理：
- 连接池复用
- 内存使用监控
- 并发限制
- 错误重试
```

## 6. 监控与日志

### 6.1 关键指标监控
```
性能指标：
- 响应时间
- 吞吐量
- 错误率
- 资源使用率

业务指标：
- 用户活跃度
- 问题解决成功率
- 平均解决时间
- 用户满意度
```

### 6.2 日志记录
```
操作日志：
- 用户操作记录
- 系统状态变更
- 错误信息记录
- 性能数据记录

审计日志：
- 数据访问记录
- 权限变更记录
- 系统配置变更
- 安全事件记录
```

## 7. 总结

ThinkingMap的交互流程设计遵循以下核心原则：

1. **用户中心**：用户始终拥有控制权，可以随时干预和调整
2. **透明化**：AI的思考过程完全可视化，用户可以理解每个步骤
3. **结构化**：复杂问题被分解为可管理的子问题
4. **实时性**：通过SSE实现实时状态同步和进度反馈
5. **可扩展**：支持多种问题类型和解决策略
6. **容错性**：完善的异常处理和错误恢复机制

该流程设计确保了系统的可用性、可维护性和用户体验，为ThinkingMap产品提供了坚实的技术基础。 